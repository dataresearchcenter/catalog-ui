import Fuse from "fuse.js";
import { ReadonlyURLSearchParams } from "next/navigation";
import calculateCatalogStats, { TFilterValueCounts } from "./catalogStats";
import { TActiveFilters, getFiltersFromUrlParams } from "./filterOptions";
import { IDatasetTransformed } from "./transformFTM";
import { applyActiveFilters } from "./util";

interface IUpdateState {
  readonly filteredDatasets: IDatasetTransformed[];
  readonly filterValueCounts: TFilterValueCounts;
  readonly activeFilters: TActiveFilters;
  readonly loading: boolean;
}

export interface IState extends IUpdateState {
  readonly datasets: IDatasetTransformed[];
  readonly searchIndex: Fuse<IDatasetTransformed>;
}

const initializeSearchIndex = (
  datasets: IDatasetTransformed[],
): Fuse<IDatasetTransformed> => {
  return new Fuse(datasets, {
    threshold: 0,
    ignoreLocation: true,
    keys: ["title", "publisher.name", "maintainer.name"],
  });
};

const updateState = (
  datasets: IDatasetTransformed[],
  activeFilters: TActiveFilters,
): IUpdateState => {
  const filteredDatasets = applyActiveFilters(datasets, activeFilters);
  const catalogStats = calculateCatalogStats(filteredDatasets);
  return {
    activeFilters,
    filteredDatasets,
    filterValueCounts: catalogStats,
    loading: false,
  };
};

interface IInitialState {
  readonly datasets: IDatasetTransformed[];
  readonly searchParams: ReadonlyURLSearchParams;
}

export function createInitialState({
  datasets,
  searchParams,
}: IInitialState): IState {
  const searchIndex = initializeSearchIndex(datasets);
  const activeFilters = getFiltersFromUrlParams(searchParams);
  return {
    datasets,
    searchIndex,
    ...updateState(datasets, activeFilters),
  };
}

export enum ACTION {
  SEARCH = "SEARCH",
  FILTER = "FILTER",
  LOADING = "LOADING",
}

type TSearchAction = {
  readonly type: ACTION.SEARCH;
  readonly value: string;
};

type TFilterAction = {
  readonly type: ACTION.FILTER;
  readonly filters: TActiveFilters;
};

type TLoadingAction = {
  readonly type: ACTION.LOADING;
};

export type TActions = TSearchAction | TFilterAction | TLoadingAction;

export default function reducer(state: IState, action: TActions) {
  switch (action.type) {
    case ACTION.LOADING:
      return { ...state, loading: true };
    case ACTION.SEARCH:
      const datasets = action.value
        ? state.searchIndex.search(action.value).map((r) => r.item)
        : state.datasets;
      return {
        ...state,
        ...updateState(datasets, state.activeFilters),
      };
    case ACTION.FILTER:
      return {
        ...state,
        ...updateState(state.datasets, action.filters),
      };
  }
}
